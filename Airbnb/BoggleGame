boggle game，给一个board和字典，找出board上出现最多的单词集合，单词不能重叠在同一个位置

例如

board:
{'a', 'b', 'c'},
{'d', 'e', 'f'},
{'g', 'h', 'i'}

dict:
["abc", "cfi", "beh", "defi", "gh"]
答案应该是 ["abc", "defi", "gh"]


这个题和 Leetcode 的 Word Search II 有点像，唯一区别是这个题里面 board 上的单词不可以重复利用。刚开始我觉得可以 run 一次 Word Search II 得到所有的可能单词先，然后求最大的一个单词无重合集合，但是找无重合集合这个又变成一个 subset 的题目（我没有研究更快的方法）。所以最后还是考虑用控制一下递归搜索的条件，在找单词的时候记录一下已经选中的单词，只是这个过程需要两层递归。

还是用一个 Trie 来加速 Word 的查找
第一个循环，遍历 board 上每一个点，然后从这里找第一个单词（因为第一个单词的选择会影响最终单词数量），开始第一个递归。
第一个递归的作用是，从当前点开始，通过第二个递归拿到当前点可行的每一个单词。挨个放入，每放入一个更新当前 board 的使用情况，然后开始下一层搜索。
第二个递归的作用是，从当前点开始，找所有可行的单词 indexes，为第一个递归提供选择


